// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RtcSdpDefine.proto

#ifndef PROTOBUF_INCLUDED_RtcSdpDefine_2eproto
#define PROTOBUF_INCLUDED_RtcSdpDefine_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include "RtcSdpEnumDefine.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_RtcSdpDefine_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_RtcSdpDefine_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[19]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
class Crypto_Params;
class Crypto_ParamsDefaultTypeInternal;
extern Crypto_ParamsDefaultTypeInternal _Crypto_Params_default_instance_;
class RTC_Candidate;
class RTC_CandidateDefaultTypeInternal;
extern RTC_CandidateDefaultTypeInternal _RTC_Candidate_default_instance_;
class Rid_Description;
class Rid_DescriptionDefaultTypeInternal;
extern Rid_DescriptionDefaultTypeInternal _Rid_Description_default_instance_;
class Rid_Description_RestrictionsEntry_DoNotUse;
class Rid_Description_RestrictionsEntry_DoNotUseDefaultTypeInternal;
extern Rid_Description_RestrictionsEntry_DoNotUseDefaultTypeInternal _Rid_Description_RestrictionsEntry_DoNotUse_default_instance_;
class Rtc_Audio_Codec;
class Rtc_Audio_CodecDefaultTypeInternal;
extern Rtc_Audio_CodecDefaultTypeInternal _Rtc_Audio_Codec_default_instance_;
class Rtc_Candidate;
class Rtc_CandidateDefaultTypeInternal;
extern Rtc_CandidateDefaultTypeInternal _Rtc_Candidate_default_instance_;
class Rtc_Codec;
class Rtc_CodecDefaultTypeInternal;
extern Rtc_CodecDefaultTypeInternal _Rtc_Codec_default_instance_;
class Rtc_Codec_ParamsEntry_DoNotUse;
class Rtc_Codec_ParamsEntry_DoNotUseDefaultTypeInternal;
extern Rtc_Codec_ParamsEntry_DoNotUseDefaultTypeInternal _Rtc_Codec_ParamsEntry_DoNotUse_default_instance_;
class Rtc_Data_Codec;
class Rtc_Data_CodecDefaultTypeInternal;
extern Rtc_Data_CodecDefaultTypeInternal _Rtc_Data_Codec_default_instance_;
class Rtc_Feedback_Param;
class Rtc_Feedback_ParamDefaultTypeInternal;
extern Rtc_Feedback_ParamDefaultTypeInternal _Rtc_Feedback_Param_default_instance_;
class Rtc_Ssrc_Info;
class Rtc_Ssrc_InfoDefaultTypeInternal;
extern Rtc_Ssrc_InfoDefaultTypeInternal _Rtc_Ssrc_Info_default_instance_;
class Rtc_Video_Codec;
class Rtc_Video_CodecDefaultTypeInternal;
extern Rtc_Video_CodecDefaultTypeInternal _Rtc_Video_Codec_default_instance_;
class Rtp_Extension;
class Rtp_ExtensionDefaultTypeInternal;
extern Rtp_ExtensionDefaultTypeInternal _Rtp_Extension_default_instance_;
class Simulcast_Description;
class Simulcast_DescriptionDefaultTypeInternal;
extern Simulcast_DescriptionDefaultTypeInternal _Simulcast_Description_default_instance_;
class Simulcast_Layer;
class Simulcast_LayerDefaultTypeInternal;
extern Simulcast_LayerDefaultTypeInternal _Simulcast_Layer_default_instance_;
class Simulcast_Layer_List;
class Simulcast_Layer_ListDefaultTypeInternal;
extern Simulcast_Layer_ListDefaultTypeInternal _Simulcast_Layer_List_default_instance_;
class Socket_Address;
class Socket_AddressDefaultTypeInternal;
extern Socket_AddressDefaultTypeInternal _Socket_Address_default_instance_;
class Ssl_Fignerpint;
class Ssl_FignerpintDefaultTypeInternal;
extern Ssl_FignerpintDefaultTypeInternal _Ssl_Fignerpint_default_instance_;
class Ssrc_Group;
class Ssrc_GroupDefaultTypeInternal;
extern Ssrc_GroupDefaultTypeInternal _Ssrc_Group_default_instance_;
namespace google {
namespace protobuf {
template<> ::Crypto_Params* Arena::CreateMaybeMessage<::Crypto_Params>(Arena*);
template<> ::RTC_Candidate* Arena::CreateMaybeMessage<::RTC_Candidate>(Arena*);
template<> ::Rid_Description* Arena::CreateMaybeMessage<::Rid_Description>(Arena*);
template<> ::Rid_Description_RestrictionsEntry_DoNotUse* Arena::CreateMaybeMessage<::Rid_Description_RestrictionsEntry_DoNotUse>(Arena*);
template<> ::Rtc_Audio_Codec* Arena::CreateMaybeMessage<::Rtc_Audio_Codec>(Arena*);
template<> ::Rtc_Candidate* Arena::CreateMaybeMessage<::Rtc_Candidate>(Arena*);
template<> ::Rtc_Codec* Arena::CreateMaybeMessage<::Rtc_Codec>(Arena*);
template<> ::Rtc_Codec_ParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::Rtc_Codec_ParamsEntry_DoNotUse>(Arena*);
template<> ::Rtc_Data_Codec* Arena::CreateMaybeMessage<::Rtc_Data_Codec>(Arena*);
template<> ::Rtc_Feedback_Param* Arena::CreateMaybeMessage<::Rtc_Feedback_Param>(Arena*);
template<> ::Rtc_Ssrc_Info* Arena::CreateMaybeMessage<::Rtc_Ssrc_Info>(Arena*);
template<> ::Rtc_Video_Codec* Arena::CreateMaybeMessage<::Rtc_Video_Codec>(Arena*);
template<> ::Rtp_Extension* Arena::CreateMaybeMessage<::Rtp_Extension>(Arena*);
template<> ::Simulcast_Description* Arena::CreateMaybeMessage<::Simulcast_Description>(Arena*);
template<> ::Simulcast_Layer* Arena::CreateMaybeMessage<::Simulcast_Layer>(Arena*);
template<> ::Simulcast_Layer_List* Arena::CreateMaybeMessage<::Simulcast_Layer_List>(Arena*);
template<> ::Socket_Address* Arena::CreateMaybeMessage<::Socket_Address>(Arena*);
template<> ::Ssl_Fignerpint* Arena::CreateMaybeMessage<::Ssl_Fignerpint>(Arena*);
template<> ::Ssrc_Group* Arena::CreateMaybeMessage<::Ssrc_Group>(Arena*);
}  // namespace protobuf
}  // namespace google

// ===================================================================

class Ssl_Fignerpint final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Ssl_Fignerpint) */ {
 public:
  Ssl_Fignerpint();
  virtual ~Ssl_Fignerpint();

  Ssl_Fignerpint(const Ssl_Fignerpint& from);

  inline Ssl_Fignerpint& operator=(const Ssl_Fignerpint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ssl_Fignerpint(Ssl_Fignerpint&& from) noexcept
    : Ssl_Fignerpint() {
    *this = ::std::move(from);
  }

  inline Ssl_Fignerpint& operator=(Ssl_Fignerpint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Ssl_Fignerpint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ssl_Fignerpint* internal_default_instance() {
    return reinterpret_cast<const Ssl_Fignerpint*>(
               &_Ssl_Fignerpint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Ssl_Fignerpint* other);
  friend void swap(Ssl_Fignerpint& a, Ssl_Fignerpint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ssl_Fignerpint* New() const final {
    return CreateMaybeMessage<Ssl_Fignerpint>(nullptr);
  }

  Ssl_Fignerpint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ssl_Fignerpint>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Ssl_Fignerpint& from);
  void MergeFrom(const Ssl_Fignerpint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ssl_Fignerpint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string algorithm = 1;
  bool has_algorithm() const;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 1;
  const ::std::string& algorithm() const;
  void set_algorithm(const ::std::string& value);
  #if LANG_CXX11
  void set_algorithm(::std::string&& value);
  #endif
  void set_algorithm(const char* value);
  void set_algorithm(const char* value, size_t size);
  ::std::string* mutable_algorithm();
  ::std::string* release_algorithm();
  void set_allocated_algorithm(::std::string* algorithm);

  // optional string digest = 2;
  bool has_digest() const;
  void clear_digest();
  static const int kDigestFieldNumber = 2;
  const ::std::string& digest() const;
  void set_digest(const ::std::string& value);
  #if LANG_CXX11
  void set_digest(::std::string&& value);
  #endif
  void set_digest(const char* value);
  void set_digest(const char* value, size_t size);
  ::std::string* mutable_digest();
  ::std::string* release_digest();
  void set_allocated_digest(::std::string* digest);

  // @@protoc_insertion_point(class_scope:Ssl_Fignerpint)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr algorithm_;
  ::google::protobuf::internal::ArenaStringPtr digest_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Crypto_Params final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Crypto_Params) */ {
 public:
  Crypto_Params();
  virtual ~Crypto_Params();

  Crypto_Params(const Crypto_Params& from);

  inline Crypto_Params& operator=(const Crypto_Params& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Crypto_Params(Crypto_Params&& from) noexcept
    : Crypto_Params() {
    *this = ::std::move(from);
  }

  inline Crypto_Params& operator=(Crypto_Params&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Crypto_Params& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Crypto_Params* internal_default_instance() {
    return reinterpret_cast<const Crypto_Params*>(
               &_Crypto_Params_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Crypto_Params* other);
  friend void swap(Crypto_Params& a, Crypto_Params& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Crypto_Params* New() const final {
    return CreateMaybeMessage<Crypto_Params>(nullptr);
  }

  Crypto_Params* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Crypto_Params>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Crypto_Params& from);
  void MergeFrom(const Crypto_Params& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Crypto_Params* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cipher_suite = 2;
  bool has_cipher_suite() const;
  void clear_cipher_suite();
  static const int kCipherSuiteFieldNumber = 2;
  const ::std::string& cipher_suite() const;
  void set_cipher_suite(const ::std::string& value);
  #if LANG_CXX11
  void set_cipher_suite(::std::string&& value);
  #endif
  void set_cipher_suite(const char* value);
  void set_cipher_suite(const char* value, size_t size);
  ::std::string* mutable_cipher_suite();
  ::std::string* release_cipher_suite();
  void set_allocated_cipher_suite(::std::string* cipher_suite);

  // optional string key_params = 3;
  bool has_key_params() const;
  void clear_key_params();
  static const int kKeyParamsFieldNumber = 3;
  const ::std::string& key_params() const;
  void set_key_params(const ::std::string& value);
  #if LANG_CXX11
  void set_key_params(::std::string&& value);
  #endif
  void set_key_params(const char* value);
  void set_key_params(const char* value, size_t size);
  ::std::string* mutable_key_params();
  ::std::string* release_key_params();
  void set_allocated_key_params(::std::string* key_params);

  // optional string session_params = 4;
  bool has_session_params() const;
  void clear_session_params();
  static const int kSessionParamsFieldNumber = 4;
  const ::std::string& session_params() const;
  void set_session_params(const ::std::string& value);
  #if LANG_CXX11
  void set_session_params(::std::string&& value);
  #endif
  void set_session_params(const char* value);
  void set_session_params(const char* value, size_t size);
  ::std::string* mutable_session_params();
  ::std::string* release_session_params();
  void set_allocated_session_params(::std::string* session_params);

  // optional int32 tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  ::google::protobuf::int32 tag() const;
  void set_tag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Crypto_Params)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr cipher_suite_;
  ::google::protobuf::internal::ArenaStringPtr key_params_;
  ::google::protobuf::internal::ArenaStringPtr session_params_;
  ::google::protobuf::int32 tag_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Rtp_Extension final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Rtp_Extension) */ {
 public:
  Rtp_Extension();
  virtual ~Rtp_Extension();

  Rtp_Extension(const Rtp_Extension& from);

  inline Rtp_Extension& operator=(const Rtp_Extension& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rtp_Extension(Rtp_Extension&& from) noexcept
    : Rtp_Extension() {
    *this = ::std::move(from);
  }

  inline Rtp_Extension& operator=(Rtp_Extension&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Rtp_Extension& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rtp_Extension* internal_default_instance() {
    return reinterpret_cast<const Rtp_Extension*>(
               &_Rtp_Extension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Rtp_Extension* other);
  friend void swap(Rtp_Extension& a, Rtp_Extension& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rtp_Extension* New() const final {
    return CreateMaybeMessage<Rtp_Extension>(nullptr);
  }

  Rtp_Extension* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rtp_Extension>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Rtp_Extension& from);
  void MergeFrom(const Rtp_Extension& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rtp_Extension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uri = 1;
  bool has_uri() const;
  void clear_uri();
  static const int kUriFieldNumber = 1;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // optional int32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional bool encrypt = 3;
  bool has_encrypt() const;
  void clear_encrypt();
  static const int kEncryptFieldNumber = 3;
  bool encrypt() const;
  void set_encrypt(bool value);

  // @@protoc_insertion_point(class_scope:Rtp_Extension)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::google::protobuf::int32 id_;
  bool encrypt_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Ssrc_Group final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Ssrc_Group) */ {
 public:
  Ssrc_Group();
  virtual ~Ssrc_Group();

  Ssrc_Group(const Ssrc_Group& from);

  inline Ssrc_Group& operator=(const Ssrc_Group& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ssrc_Group(Ssrc_Group&& from) noexcept
    : Ssrc_Group() {
    *this = ::std::move(from);
  }

  inline Ssrc_Group& operator=(Ssrc_Group&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Ssrc_Group& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ssrc_Group* internal_default_instance() {
    return reinterpret_cast<const Ssrc_Group*>(
               &_Ssrc_Group_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Ssrc_Group* other);
  friend void swap(Ssrc_Group& a, Ssrc_Group& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ssrc_Group* New() const final {
    return CreateMaybeMessage<Ssrc_Group>(nullptr);
  }

  Ssrc_Group* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ssrc_Group>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Ssrc_Group& from);
  void MergeFrom(const Ssrc_Group& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ssrc_Group* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 ssrcs = 2;
  int ssrcs_size() const;
  void clear_ssrcs();
  static const int kSsrcsFieldNumber = 2;
  ::google::protobuf::uint32 ssrcs(int index) const;
  void set_ssrcs(int index, ::google::protobuf::uint32 value);
  void add_ssrcs(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ssrcs() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ssrcs();

  // optional string semantics = 1;
  bool has_semantics() const;
  void clear_semantics();
  static const int kSemanticsFieldNumber = 1;
  const ::std::string& semantics() const;
  void set_semantics(const ::std::string& value);
  #if LANG_CXX11
  void set_semantics(::std::string&& value);
  #endif
  void set_semantics(const char* value);
  void set_semantics(const char* value, size_t size);
  ::std::string* mutable_semantics();
  ::std::string* release_semantics();
  void set_allocated_semantics(::std::string* semantics);

  // @@protoc_insertion_point(class_scope:Ssrc_Group)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ssrcs_;
  ::google::protobuf::internal::ArenaStringPtr semantics_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Rid_Description_RestrictionsEntry_DoNotUse : public ::google::protobuf::internal::MapEntryLite<Rid_Description_RestrictionsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntryLite<Rid_Description_RestrictionsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Rid_Description_RestrictionsEntry_DoNotUse();
  Rid_Description_RestrictionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Rid_Description_RestrictionsEntry_DoNotUse& other);
  static const Rid_Description_RestrictionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Rid_Description_RestrictionsEntry_DoNotUse*>(&_Rid_Description_RestrictionsEntry_DoNotUse_default_instance_); }
};

// -------------------------------------------------------------------

class Rid_Description final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Rid_Description) */ {
 public:
  Rid_Description();
  virtual ~Rid_Description();

  Rid_Description(const Rid_Description& from);

  inline Rid_Description& operator=(const Rid_Description& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rid_Description(Rid_Description&& from) noexcept
    : Rid_Description() {
    *this = ::std::move(from);
  }

  inline Rid_Description& operator=(Rid_Description&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Rid_Description& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rid_Description* internal_default_instance() {
    return reinterpret_cast<const Rid_Description*>(
               &_Rid_Description_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Rid_Description* other);
  friend void swap(Rid_Description& a, Rid_Description& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rid_Description* New() const final {
    return CreateMaybeMessage<Rid_Description>(nullptr);
  }

  Rid_Description* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rid_Description>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Rid_Description& from);
  void MergeFrom(const Rid_Description& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rid_Description* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated int32 payload_types = 3;
  int payload_types_size() const;
  void clear_payload_types();
  static const int kPayloadTypesFieldNumber = 3;
  ::google::protobuf::int32 payload_types(int index) const;
  void set_payload_types(int index, ::google::protobuf::int32 value);
  void add_payload_types(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      payload_types() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_payload_types();

  // map<string, string> restrictions = 4;
  int restrictions_size() const;
  void clear_restrictions();
  static const int kRestrictionsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      restrictions() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_restrictions();

  // optional string rid = 1;
  bool has_rid() const;
  void clear_rid();
  static const int kRidFieldNumber = 1;
  const ::std::string& rid() const;
  void set_rid(const ::std::string& value);
  #if LANG_CXX11
  void set_rid(::std::string&& value);
  #endif
  void set_rid(const char* value);
  void set_rid(const char* value, size_t size);
  ::std::string* mutable_rid();
  ::std::string* release_rid();
  void set_allocated_rid(::std::string* rid);

  // optional .Rid_Direction direction = 2;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::Rid_Direction direction() const;
  void set_direction(::Rid_Direction value);

  // @@protoc_insertion_point(class_scope:Rid_Description)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > payload_types_;
  ::google::protobuf::internal::MapFieldLite<
      Rid_Description_RestrictionsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > restrictions_;
  ::google::protobuf::internal::ArenaStringPtr rid_;
  int direction_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Socket_Address final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Socket_Address) */ {
 public:
  Socket_Address();
  virtual ~Socket_Address();

  Socket_Address(const Socket_Address& from);

  inline Socket_Address& operator=(const Socket_Address& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Socket_Address(Socket_Address&& from) noexcept
    : Socket_Address() {
    *this = ::std::move(from);
  }

  inline Socket_Address& operator=(Socket_Address&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Socket_Address& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Socket_Address* internal_default_instance() {
    return reinterpret_cast<const Socket_Address*>(
               &_Socket_Address_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Socket_Address* other);
  friend void swap(Socket_Address& a, Socket_Address& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Socket_Address* New() const final {
    return CreateMaybeMessage<Socket_Address>(nullptr);
  }

  Socket_Address* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Socket_Address>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Socket_Address& from);
  void MergeFrom(const Socket_Address& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Socket_Address* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // optional string ip = 2;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional uint32 port = 3;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // optional int32 scope_id = 4;
  bool has_scope_id() const;
  void clear_scope_id();
  static const int kScopeIdFieldNumber = 4;
  ::google::protobuf::int32 scope_id() const;
  void set_scope_id(::google::protobuf::int32 value);

  // optional bool literal = 5;
  bool has_literal() const;
  void clear_literal();
  static const int kLiteralFieldNumber = 5;
  bool literal() const;
  void set_literal(bool value);

  // @@protoc_insertion_point(class_scope:Socket_Address)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::int32 scope_id_;
  bool literal_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Simulcast_Layer final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Simulcast_Layer) */ {
 public:
  Simulcast_Layer();
  virtual ~Simulcast_Layer();

  Simulcast_Layer(const Simulcast_Layer& from);

  inline Simulcast_Layer& operator=(const Simulcast_Layer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Simulcast_Layer(Simulcast_Layer&& from) noexcept
    : Simulcast_Layer() {
    *this = ::std::move(from);
  }

  inline Simulcast_Layer& operator=(Simulcast_Layer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Simulcast_Layer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Simulcast_Layer* internal_default_instance() {
    return reinterpret_cast<const Simulcast_Layer*>(
               &_Simulcast_Layer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Simulcast_Layer* other);
  friend void swap(Simulcast_Layer& a, Simulcast_Layer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Simulcast_Layer* New() const final {
    return CreateMaybeMessage<Simulcast_Layer>(nullptr);
  }

  Simulcast_Layer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Simulcast_Layer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Simulcast_Layer& from);
  void MergeFrom(const Simulcast_Layer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Simulcast_Layer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string rid = 1;
  bool has_rid() const;
  void clear_rid();
  static const int kRidFieldNumber = 1;
  const ::std::string& rid() const;
  void set_rid(const ::std::string& value);
  #if LANG_CXX11
  void set_rid(::std::string&& value);
  #endif
  void set_rid(const char* value);
  void set_rid(const char* value, size_t size);
  ::std::string* mutable_rid();
  ::std::string* release_rid();
  void set_allocated_rid(::std::string* rid);

  // optional bool is_paused = 2;
  bool has_is_paused() const;
  void clear_is_paused();
  static const int kIsPausedFieldNumber = 2;
  bool is_paused() const;
  void set_is_paused(bool value);

  // @@protoc_insertion_point(class_scope:Simulcast_Layer)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rid_;
  bool is_paused_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Simulcast_Layer_List final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Simulcast_Layer_List) */ {
 public:
  Simulcast_Layer_List();
  virtual ~Simulcast_Layer_List();

  Simulcast_Layer_List(const Simulcast_Layer_List& from);

  inline Simulcast_Layer_List& operator=(const Simulcast_Layer_List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Simulcast_Layer_List(Simulcast_Layer_List&& from) noexcept
    : Simulcast_Layer_List() {
    *this = ::std::move(from);
  }

  inline Simulcast_Layer_List& operator=(Simulcast_Layer_List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Simulcast_Layer_List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Simulcast_Layer_List* internal_default_instance() {
    return reinterpret_cast<const Simulcast_Layer_List*>(
               &_Simulcast_Layer_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Simulcast_Layer_List* other);
  friend void swap(Simulcast_Layer_List& a, Simulcast_Layer_List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Simulcast_Layer_List* New() const final {
    return CreateMaybeMessage<Simulcast_Layer_List>(nullptr);
  }

  Simulcast_Layer_List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Simulcast_Layer_List>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Simulcast_Layer_List& from);
  void MergeFrom(const Simulcast_Layer_List& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Simulcast_Layer_List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Simulcast_Layer list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::Simulcast_Layer* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer >*
      mutable_list();
  const ::Simulcast_Layer& list(int index) const;
  ::Simulcast_Layer* add_list();
  const ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer >&
      list() const;

  // @@protoc_insertion_point(class_scope:Simulcast_Layer_List)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer > list_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Simulcast_Description final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Simulcast_Description) */ {
 public:
  Simulcast_Description();
  virtual ~Simulcast_Description();

  Simulcast_Description(const Simulcast_Description& from);

  inline Simulcast_Description& operator=(const Simulcast_Description& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Simulcast_Description(Simulcast_Description&& from) noexcept
    : Simulcast_Description() {
    *this = ::std::move(from);
  }

  inline Simulcast_Description& operator=(Simulcast_Description&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Simulcast_Description& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Simulcast_Description* internal_default_instance() {
    return reinterpret_cast<const Simulcast_Description*>(
               &_Simulcast_Description_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Simulcast_Description* other);
  friend void swap(Simulcast_Description& a, Simulcast_Description& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Simulcast_Description* New() const final {
    return CreateMaybeMessage<Simulcast_Description>(nullptr);
  }

  Simulcast_Description* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Simulcast_Description>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Simulcast_Description& from);
  void MergeFrom(const Simulcast_Description& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Simulcast_Description* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Simulcast_Layer_List send_layers = 1;
  int send_layers_size() const;
  void clear_send_layers();
  static const int kSendLayersFieldNumber = 1;
  ::Simulcast_Layer_List* mutable_send_layers(int index);
  ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer_List >*
      mutable_send_layers();
  const ::Simulcast_Layer_List& send_layers(int index) const;
  ::Simulcast_Layer_List* add_send_layers();
  const ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer_List >&
      send_layers() const;

  // repeated .Simulcast_Layer_List receive_layers = 2;
  int receive_layers_size() const;
  void clear_receive_layers();
  static const int kReceiveLayersFieldNumber = 2;
  ::Simulcast_Layer_List* mutable_receive_layers(int index);
  ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer_List >*
      mutable_receive_layers();
  const ::Simulcast_Layer_List& receive_layers(int index) const;
  ::Simulcast_Layer_List* add_receive_layers();
  const ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer_List >&
      receive_layers() const;

  // @@protoc_insertion_point(class_scope:Simulcast_Description)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer_List > send_layers_;
  ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer_List > receive_layers_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class RTC_Candidate final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:RTC_Candidate) */ {
 public:
  RTC_Candidate();
  virtual ~RTC_Candidate();

  RTC_Candidate(const RTC_Candidate& from);

  inline RTC_Candidate& operator=(const RTC_Candidate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RTC_Candidate(RTC_Candidate&& from) noexcept
    : RTC_Candidate() {
    *this = ::std::move(from);
  }

  inline RTC_Candidate& operator=(RTC_Candidate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RTC_Candidate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RTC_Candidate* internal_default_instance() {
    return reinterpret_cast<const RTC_Candidate*>(
               &_RTC_Candidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(RTC_Candidate* other);
  friend void swap(RTC_Candidate& a, RTC_Candidate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RTC_Candidate* New() const final {
    return CreateMaybeMessage<RTC_Candidate>(nullptr);
  }

  RTC_Candidate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RTC_Candidate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RTC_Candidate& from);
  void MergeFrom(const RTC_Candidate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RTC_Candidate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RTC_Candidate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Rtc_Ssrc_Info final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Rtc_Ssrc_Info) */ {
 public:
  Rtc_Ssrc_Info();
  virtual ~Rtc_Ssrc_Info();

  Rtc_Ssrc_Info(const Rtc_Ssrc_Info& from);

  inline Rtc_Ssrc_Info& operator=(const Rtc_Ssrc_Info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rtc_Ssrc_Info(Rtc_Ssrc_Info&& from) noexcept
    : Rtc_Ssrc_Info() {
    *this = ::std::move(from);
  }

  inline Rtc_Ssrc_Info& operator=(Rtc_Ssrc_Info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Rtc_Ssrc_Info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rtc_Ssrc_Info* internal_default_instance() {
    return reinterpret_cast<const Rtc_Ssrc_Info*>(
               &_Rtc_Ssrc_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Rtc_Ssrc_Info* other);
  friend void swap(Rtc_Ssrc_Info& a, Rtc_Ssrc_Info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rtc_Ssrc_Info* New() const final {
    return CreateMaybeMessage<Rtc_Ssrc_Info>(nullptr);
  }

  Rtc_Ssrc_Info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rtc_Ssrc_Info>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Rtc_Ssrc_Info& from);
  void MergeFrom(const Rtc_Ssrc_Info& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rtc_Ssrc_Info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cname = 2;
  bool has_cname() const;
  void clear_cname();
  static const int kCnameFieldNumber = 2;
  const ::std::string& cname() const;
  void set_cname(const ::std::string& value);
  #if LANG_CXX11
  void set_cname(::std::string&& value);
  #endif
  void set_cname(const char* value);
  void set_cname(const char* value, size_t size);
  ::std::string* mutable_cname();
  ::std::string* release_cname();
  void set_allocated_cname(::std::string* cname);

  // optional string stream_id = 3;
  bool has_stream_id() const;
  void clear_stream_id();
  static const int kStreamIdFieldNumber = 3;
  const ::std::string& stream_id() const;
  void set_stream_id(const ::std::string& value);
  #if LANG_CXX11
  void set_stream_id(::std::string&& value);
  #endif
  void set_stream_id(const char* value);
  void set_stream_id(const char* value, size_t size);
  ::std::string* mutable_stream_id();
  ::std::string* release_stream_id();
  void set_allocated_stream_id(::std::string* stream_id);

  // optional string track_id = 4;
  bool has_track_id() const;
  void clear_track_id();
  static const int kTrackIdFieldNumber = 4;
  const ::std::string& track_id() const;
  void set_track_id(const ::std::string& value);
  #if LANG_CXX11
  void set_track_id(::std::string&& value);
  #endif
  void set_track_id(const char* value);
  void set_track_id(const char* value, size_t size);
  ::std::string* mutable_track_id();
  ::std::string* release_track_id();
  void set_allocated_track_id(::std::string* track_id);

  // optional string label = 5;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 5;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // optional string mslabel = 6;
  bool has_mslabel() const;
  void clear_mslabel();
  static const int kMslabelFieldNumber = 6;
  const ::std::string& mslabel() const;
  void set_mslabel(const ::std::string& value);
  #if LANG_CXX11
  void set_mslabel(::std::string&& value);
  #endif
  void set_mslabel(const char* value);
  void set_mslabel(const char* value, size_t size);
  ::std::string* mutable_mslabel();
  ::std::string* release_mslabel();
  void set_allocated_mslabel(::std::string* mslabel);

  // optional uint32 ssrc_id = 1;
  bool has_ssrc_id() const;
  void clear_ssrc_id();
  static const int kSsrcIdFieldNumber = 1;
  ::google::protobuf::uint32 ssrc_id() const;
  void set_ssrc_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Rtc_Ssrc_Info)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr cname_;
  ::google::protobuf::internal::ArenaStringPtr stream_id_;
  ::google::protobuf::internal::ArenaStringPtr track_id_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr mslabel_;
  ::google::protobuf::uint32 ssrc_id_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Rtc_Feedback_Param final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Rtc_Feedback_Param) */ {
 public:
  Rtc_Feedback_Param();
  virtual ~Rtc_Feedback_Param();

  Rtc_Feedback_Param(const Rtc_Feedback_Param& from);

  inline Rtc_Feedback_Param& operator=(const Rtc_Feedback_Param& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rtc_Feedback_Param(Rtc_Feedback_Param&& from) noexcept
    : Rtc_Feedback_Param() {
    *this = ::std::move(from);
  }

  inline Rtc_Feedback_Param& operator=(Rtc_Feedback_Param&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Rtc_Feedback_Param& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rtc_Feedback_Param* internal_default_instance() {
    return reinterpret_cast<const Rtc_Feedback_Param*>(
               &_Rtc_Feedback_Param_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Rtc_Feedback_Param* other);
  friend void swap(Rtc_Feedback_Param& a, Rtc_Feedback_Param& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rtc_Feedback_Param* New() const final {
    return CreateMaybeMessage<Rtc_Feedback_Param>(nullptr);
  }

  Rtc_Feedback_Param* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rtc_Feedback_Param>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Rtc_Feedback_Param& from);
  void MergeFrom(const Rtc_Feedback_Param& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rtc_Feedback_Param* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string param = 2;
  bool has_param() const;
  void clear_param();
  static const int kParamFieldNumber = 2;
  const ::std::string& param() const;
  void set_param(const ::std::string& value);
  #if LANG_CXX11
  void set_param(::std::string&& value);
  #endif
  void set_param(const char* value);
  void set_param(const char* value, size_t size);
  ::std::string* mutable_param();
  ::std::string* release_param();
  void set_allocated_param(::std::string* param);

  // @@protoc_insertion_point(class_scope:Rtc_Feedback_Param)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr param_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Rtc_Codec_ParamsEntry_DoNotUse : public ::google::protobuf::internal::MapEntryLite<Rtc_Codec_ParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntryLite<Rtc_Codec_ParamsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Rtc_Codec_ParamsEntry_DoNotUse();
  Rtc_Codec_ParamsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Rtc_Codec_ParamsEntry_DoNotUse& other);
  static const Rtc_Codec_ParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Rtc_Codec_ParamsEntry_DoNotUse*>(&_Rtc_Codec_ParamsEntry_DoNotUse_default_instance_); }
};

// -------------------------------------------------------------------

class Rtc_Codec final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Rtc_Codec) */ {
 public:
  Rtc_Codec();
  virtual ~Rtc_Codec();

  Rtc_Codec(const Rtc_Codec& from);

  inline Rtc_Codec& operator=(const Rtc_Codec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rtc_Codec(Rtc_Codec&& from) noexcept
    : Rtc_Codec() {
    *this = ::std::move(from);
  }

  inline Rtc_Codec& operator=(Rtc_Codec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Rtc_Codec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rtc_Codec* internal_default_instance() {
    return reinterpret_cast<const Rtc_Codec*>(
               &_Rtc_Codec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Rtc_Codec* other);
  friend void swap(Rtc_Codec& a, Rtc_Codec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rtc_Codec* New() const final {
    return CreateMaybeMessage<Rtc_Codec>(nullptr);
  }

  Rtc_Codec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rtc_Codec>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Rtc_Codec& from);
  void MergeFrom(const Rtc_Codec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rtc_Codec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> params = 4;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      params() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_params();

  // repeated .Rtc_Feedback_Param feedback_params = 5;
  int feedback_params_size() const;
  void clear_feedback_params();
  static const int kFeedbackParamsFieldNumber = 5;
  ::Rtc_Feedback_Param* mutable_feedback_params(int index);
  ::google::protobuf::RepeatedPtrField< ::Rtc_Feedback_Param >*
      mutable_feedback_params();
  const ::Rtc_Feedback_Param& feedback_params(int index) const;
  ::Rtc_Feedback_Param* add_feedback_params();
  const ::google::protobuf::RepeatedPtrField< ::Rtc_Feedback_Param >&
      feedback_params() const;

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional int32 clockrate = 3;
  bool has_clockrate() const;
  void clear_clockrate();
  static const int kClockrateFieldNumber = 3;
  ::google::protobuf::int32 clockrate() const;
  void set_clockrate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Rtc_Codec)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::MapFieldLite<
      Rtc_Codec_ParamsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > params_;
  ::google::protobuf::RepeatedPtrField< ::Rtc_Feedback_Param > feedback_params_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 clockrate_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Rtc_Audio_Codec final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Rtc_Audio_Codec) */ {
 public:
  Rtc_Audio_Codec();
  virtual ~Rtc_Audio_Codec();

  Rtc_Audio_Codec(const Rtc_Audio_Codec& from);

  inline Rtc_Audio_Codec& operator=(const Rtc_Audio_Codec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rtc_Audio_Codec(Rtc_Audio_Codec&& from) noexcept
    : Rtc_Audio_Codec() {
    *this = ::std::move(from);
  }

  inline Rtc_Audio_Codec& operator=(Rtc_Audio_Codec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Rtc_Audio_Codec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rtc_Audio_Codec* internal_default_instance() {
    return reinterpret_cast<const Rtc_Audio_Codec*>(
               &_Rtc_Audio_Codec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Rtc_Audio_Codec* other);
  friend void swap(Rtc_Audio_Codec& a, Rtc_Audio_Codec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rtc_Audio_Codec* New() const final {
    return CreateMaybeMessage<Rtc_Audio_Codec>(nullptr);
  }

  Rtc_Audio_Codec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rtc_Audio_Codec>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Rtc_Audio_Codec& from);
  void MergeFrom(const Rtc_Audio_Codec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rtc_Audio_Codec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Rtc_Codec codecs = 3;
  bool has_codecs() const;
  void clear_codecs();
  static const int kCodecsFieldNumber = 3;
  const ::Rtc_Codec& codecs() const;
  ::Rtc_Codec* release_codecs();
  ::Rtc_Codec* mutable_codecs();
  void set_allocated_codecs(::Rtc_Codec* codecs);

  // optional int32 bitrate = 1;
  bool has_bitrate() const;
  void clear_bitrate();
  static const int kBitrateFieldNumber = 1;
  ::google::protobuf::int32 bitrate() const;
  void set_bitrate(::google::protobuf::int32 value);

  // optional int32 channels = 2;
  bool has_channels() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 2;
  ::google::protobuf::int32 channels() const;
  void set_channels(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Rtc_Audio_Codec)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::Rtc_Codec* codecs_;
  ::google::protobuf::int32 bitrate_;
  ::google::protobuf::int32 channels_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Rtc_Video_Codec final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Rtc_Video_Codec) */ {
 public:
  Rtc_Video_Codec();
  virtual ~Rtc_Video_Codec();

  Rtc_Video_Codec(const Rtc_Video_Codec& from);

  inline Rtc_Video_Codec& operator=(const Rtc_Video_Codec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rtc_Video_Codec(Rtc_Video_Codec&& from) noexcept
    : Rtc_Video_Codec() {
    *this = ::std::move(from);
  }

  inline Rtc_Video_Codec& operator=(Rtc_Video_Codec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Rtc_Video_Codec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rtc_Video_Codec* internal_default_instance() {
    return reinterpret_cast<const Rtc_Video_Codec*>(
               &_Rtc_Video_Codec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Rtc_Video_Codec* other);
  friend void swap(Rtc_Video_Codec& a, Rtc_Video_Codec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rtc_Video_Codec* New() const final {
    return CreateMaybeMessage<Rtc_Video_Codec>(nullptr);
  }

  Rtc_Video_Codec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rtc_Video_Codec>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Rtc_Video_Codec& from);
  void MergeFrom(const Rtc_Video_Codec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rtc_Video_Codec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Rtc_Codec codecs = 1;
  bool has_codecs() const;
  void clear_codecs();
  static const int kCodecsFieldNumber = 1;
  const ::Rtc_Codec& codecs() const;
  ::Rtc_Codec* release_codecs();
  ::Rtc_Codec* mutable_codecs();
  void set_allocated_codecs(::Rtc_Codec* codecs);

  // @@protoc_insertion_point(class_scope:Rtc_Video_Codec)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::Rtc_Codec* codecs_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Rtc_Data_Codec final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Rtc_Data_Codec) */ {
 public:
  Rtc_Data_Codec();
  virtual ~Rtc_Data_Codec();

  Rtc_Data_Codec(const Rtc_Data_Codec& from);

  inline Rtc_Data_Codec& operator=(const Rtc_Data_Codec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rtc_Data_Codec(Rtc_Data_Codec&& from) noexcept
    : Rtc_Data_Codec() {
    *this = ::std::move(from);
  }

  inline Rtc_Data_Codec& operator=(Rtc_Data_Codec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Rtc_Data_Codec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rtc_Data_Codec* internal_default_instance() {
    return reinterpret_cast<const Rtc_Data_Codec*>(
               &_Rtc_Data_Codec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Rtc_Data_Codec* other);
  friend void swap(Rtc_Data_Codec& a, Rtc_Data_Codec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rtc_Data_Codec* New() const final {
    return CreateMaybeMessage<Rtc_Data_Codec>(nullptr);
  }

  Rtc_Data_Codec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rtc_Data_Codec>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Rtc_Data_Codec& from);
  void MergeFrom(const Rtc_Data_Codec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rtc_Data_Codec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Rtc_Codec codecs = 1;
  bool has_codecs() const;
  void clear_codecs();
  static const int kCodecsFieldNumber = 1;
  const ::Rtc_Codec& codecs() const;
  ::Rtc_Codec* release_codecs();
  ::Rtc_Codec* mutable_codecs();
  void set_allocated_codecs(::Rtc_Codec* codecs);

  // @@protoc_insertion_point(class_scope:Rtc_Data_Codec)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::Rtc_Codec* codecs_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// -------------------------------------------------------------------

class Rtc_Candidate final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Rtc_Candidate) */ {
 public:
  Rtc_Candidate();
  virtual ~Rtc_Candidate();

  Rtc_Candidate(const Rtc_Candidate& from);

  inline Rtc_Candidate& operator=(const Rtc_Candidate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rtc_Candidate(Rtc_Candidate&& from) noexcept
    : Rtc_Candidate() {
    *this = ::std::move(from);
  }

  inline Rtc_Candidate& operator=(Rtc_Candidate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Rtc_Candidate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rtc_Candidate* internal_default_instance() {
    return reinterpret_cast<const Rtc_Candidate*>(
               &_Rtc_Candidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Rtc_Candidate* other);
  friend void swap(Rtc_Candidate& a, Rtc_Candidate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rtc_Candidate* New() const final {
    return CreateMaybeMessage<Rtc_Candidate>(nullptr);
  }

  Rtc_Candidate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rtc_Candidate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Rtc_Candidate& from);
  void MergeFrom(const Rtc_Candidate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rtc_Candidate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string protocol = 3;
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  const ::std::string& protocol() const;
  void set_protocol(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol(::std::string&& value);
  #endif
  void set_protocol(const char* value);
  void set_protocol(const char* value, size_t size);
  ::std::string* mutable_protocol();
  ::std::string* release_protocol();
  void set_allocated_protocol(::std::string* protocol);

  // optional string relay_protocol = 4;
  bool has_relay_protocol() const;
  void clear_relay_protocol();
  static const int kRelayProtocolFieldNumber = 4;
  const ::std::string& relay_protocol() const;
  void set_relay_protocol(const ::std::string& value);
  #if LANG_CXX11
  void set_relay_protocol(::std::string&& value);
  #endif
  void set_relay_protocol(const char* value);
  void set_relay_protocol(const char* value, size_t size);
  ::std::string* mutable_relay_protocol();
  ::std::string* release_relay_protocol();
  void set_allocated_relay_protocol(::std::string* relay_protocol);

  // optional string username = 7;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 7;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string password = 8;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 8;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional string type = 9;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 9;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional .Socket_Address address = 5;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 5;
  const ::Socket_Address& address() const;
  ::Socket_Address* release_address();
  ::Socket_Address* mutable_address();
  void set_allocated_address(::Socket_Address* address);

  // optional int32 component = 2;
  bool has_component() const;
  void clear_component();
  static const int kComponentFieldNumber = 2;
  ::google::protobuf::int32 component() const;
  void set_component(::google::protobuf::int32 value);

  // optional uint32 priority = 6;
  bool has_priority() const;
  void clear_priority();
  static const int kPriorityFieldNumber = 6;
  ::google::protobuf::uint32 priority() const;
  void set_priority(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Rtc_Candidate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr protocol_;
  ::google::protobuf::internal::ArenaStringPtr relay_protocol_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::Socket_Address* address_;
  ::google::protobuf::int32 component_;
  ::google::protobuf::uint32 priority_;
  friend struct ::TableStruct_RtcSdpDefine_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Ssl_Fignerpint

// optional string algorithm = 1;
inline bool Ssl_Fignerpint::has_algorithm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ssl_Fignerpint::clear_algorithm() {
  algorithm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Ssl_Fignerpint::algorithm() const {
  // @@protoc_insertion_point(field_get:Ssl_Fignerpint.algorithm)
  return algorithm_.GetNoArena();
}
inline void Ssl_Fignerpint::set_algorithm(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Ssl_Fignerpint.algorithm)
}
#if LANG_CXX11
inline void Ssl_Fignerpint::set_algorithm(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  algorithm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Ssl_Fignerpint.algorithm)
}
#endif
inline void Ssl_Fignerpint::set_algorithm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Ssl_Fignerpint.algorithm)
}
inline void Ssl_Fignerpint::set_algorithm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Ssl_Fignerpint.algorithm)
}
inline ::std::string* Ssl_Fignerpint::mutable_algorithm() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:Ssl_Fignerpint.algorithm)
  return algorithm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ssl_Fignerpint::release_algorithm() {
  // @@protoc_insertion_point(field_release:Ssl_Fignerpint.algorithm)
  if (!has_algorithm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return algorithm_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ssl_Fignerpint::set_allocated_algorithm(::std::string* algorithm) {
  if (algorithm != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  algorithm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), algorithm);
  // @@protoc_insertion_point(field_set_allocated:Ssl_Fignerpint.algorithm)
}

// optional string digest = 2;
inline bool Ssl_Fignerpint::has_digest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ssl_Fignerpint::clear_digest() {
  digest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Ssl_Fignerpint::digest() const {
  // @@protoc_insertion_point(field_get:Ssl_Fignerpint.digest)
  return digest_.GetNoArena();
}
inline void Ssl_Fignerpint::set_digest(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Ssl_Fignerpint.digest)
}
#if LANG_CXX11
inline void Ssl_Fignerpint::set_digest(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  digest_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Ssl_Fignerpint.digest)
}
#endif
inline void Ssl_Fignerpint::set_digest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Ssl_Fignerpint.digest)
}
inline void Ssl_Fignerpint::set_digest(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Ssl_Fignerpint.digest)
}
inline ::std::string* Ssl_Fignerpint::mutable_digest() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:Ssl_Fignerpint.digest)
  return digest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ssl_Fignerpint::release_digest() {
  // @@protoc_insertion_point(field_release:Ssl_Fignerpint.digest)
  if (!has_digest()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return digest_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ssl_Fignerpint::set_allocated_digest(::std::string* digest) {
  if (digest != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  digest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), digest);
  // @@protoc_insertion_point(field_set_allocated:Ssl_Fignerpint.digest)
}

// -------------------------------------------------------------------

// Crypto_Params

// optional int32 tag = 1;
inline bool Crypto_Params::has_tag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Crypto_Params::clear_tag() {
  tag_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int32 Crypto_Params::tag() const {
  // @@protoc_insertion_point(field_get:Crypto_Params.tag)
  return tag_;
}
inline void Crypto_Params::set_tag(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  tag_ = value;
  // @@protoc_insertion_point(field_set:Crypto_Params.tag)
}

// optional string cipher_suite = 2;
inline bool Crypto_Params::has_cipher_suite() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Crypto_Params::clear_cipher_suite() {
  cipher_suite_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Crypto_Params::cipher_suite() const {
  // @@protoc_insertion_point(field_get:Crypto_Params.cipher_suite)
  return cipher_suite_.GetNoArena();
}
inline void Crypto_Params::set_cipher_suite(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cipher_suite_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Crypto_Params.cipher_suite)
}
#if LANG_CXX11
inline void Crypto_Params::set_cipher_suite(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  cipher_suite_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Crypto_Params.cipher_suite)
}
#endif
inline void Crypto_Params::set_cipher_suite(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  cipher_suite_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Crypto_Params.cipher_suite)
}
inline void Crypto_Params::set_cipher_suite(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  cipher_suite_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Crypto_Params.cipher_suite)
}
inline ::std::string* Crypto_Params::mutable_cipher_suite() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:Crypto_Params.cipher_suite)
  return cipher_suite_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Crypto_Params::release_cipher_suite() {
  // @@protoc_insertion_point(field_release:Crypto_Params.cipher_suite)
  if (!has_cipher_suite()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return cipher_suite_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Crypto_Params::set_allocated_cipher_suite(::std::string* cipher_suite) {
  if (cipher_suite != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cipher_suite_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cipher_suite);
  // @@protoc_insertion_point(field_set_allocated:Crypto_Params.cipher_suite)
}

// optional string key_params = 3;
inline bool Crypto_Params::has_key_params() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Crypto_Params::clear_key_params() {
  key_params_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Crypto_Params::key_params() const {
  // @@protoc_insertion_point(field_get:Crypto_Params.key_params)
  return key_params_.GetNoArena();
}
inline void Crypto_Params::set_key_params(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_params_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Crypto_Params.key_params)
}
#if LANG_CXX11
inline void Crypto_Params::set_key_params(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  key_params_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Crypto_Params.key_params)
}
#endif
inline void Crypto_Params::set_key_params(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  key_params_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Crypto_Params.key_params)
}
inline void Crypto_Params::set_key_params(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  key_params_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Crypto_Params.key_params)
}
inline ::std::string* Crypto_Params::mutable_key_params() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:Crypto_Params.key_params)
  return key_params_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Crypto_Params::release_key_params() {
  // @@protoc_insertion_point(field_release:Crypto_Params.key_params)
  if (!has_key_params()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return key_params_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Crypto_Params::set_allocated_key_params(::std::string* key_params) {
  if (key_params != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_params_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_params);
  // @@protoc_insertion_point(field_set_allocated:Crypto_Params.key_params)
}

// optional string session_params = 4;
inline bool Crypto_Params::has_session_params() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Crypto_Params::clear_session_params() {
  session_params_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& Crypto_Params::session_params() const {
  // @@protoc_insertion_point(field_get:Crypto_Params.session_params)
  return session_params_.GetNoArena();
}
inline void Crypto_Params::set_session_params(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  session_params_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Crypto_Params.session_params)
}
#if LANG_CXX11
inline void Crypto_Params::set_session_params(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  session_params_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Crypto_Params.session_params)
}
#endif
inline void Crypto_Params::set_session_params(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  session_params_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Crypto_Params.session_params)
}
inline void Crypto_Params::set_session_params(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  session_params_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Crypto_Params.session_params)
}
inline ::std::string* Crypto_Params::mutable_session_params() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:Crypto_Params.session_params)
  return session_params_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Crypto_Params::release_session_params() {
  // @@protoc_insertion_point(field_release:Crypto_Params.session_params)
  if (!has_session_params()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return session_params_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Crypto_Params::set_allocated_session_params(::std::string* session_params) {
  if (session_params != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  session_params_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_params);
  // @@protoc_insertion_point(field_set_allocated:Crypto_Params.session_params)
}

// -------------------------------------------------------------------

// Rtp_Extension

// optional string uri = 1;
inline bool Rtp_Extension::has_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rtp_Extension::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Rtp_Extension::uri() const {
  // @@protoc_insertion_point(field_get:Rtp_Extension.uri)
  return uri_.GetNoArena();
}
inline void Rtp_Extension::set_uri(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtp_Extension.uri)
}
#if LANG_CXX11
inline void Rtp_Extension::set_uri(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtp_Extension.uri)
}
#endif
inline void Rtp_Extension::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtp_Extension.uri)
}
inline void Rtp_Extension::set_uri(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtp_Extension.uri)
}
inline ::std::string* Rtp_Extension::mutable_uri() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:Rtp_Extension.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtp_Extension::release_uri() {
  // @@protoc_insertion_point(field_release:Rtp_Extension.uri)
  if (!has_uri()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return uri_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtp_Extension::set_allocated_uri(::std::string* uri) {
  if (uri != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:Rtp_Extension.uri)
}

// optional int32 id = 2;
inline bool Rtp_Extension::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rtp_Extension::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 Rtp_Extension::id() const {
  // @@protoc_insertion_point(field_get:Rtp_Extension.id)
  return id_;
}
inline void Rtp_Extension::set_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
  // @@protoc_insertion_point(field_set:Rtp_Extension.id)
}

// optional bool encrypt = 3;
inline bool Rtp_Extension::has_encrypt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rtp_Extension::clear_encrypt() {
  encrypt_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Rtp_Extension::encrypt() const {
  // @@protoc_insertion_point(field_get:Rtp_Extension.encrypt)
  return encrypt_;
}
inline void Rtp_Extension::set_encrypt(bool value) {
  _has_bits_[0] |= 0x00000004u;
  encrypt_ = value;
  // @@protoc_insertion_point(field_set:Rtp_Extension.encrypt)
}

// -------------------------------------------------------------------

// Ssrc_Group

// optional string semantics = 1;
inline bool Ssrc_Group::has_semantics() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ssrc_Group::clear_semantics() {
  semantics_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Ssrc_Group::semantics() const {
  // @@protoc_insertion_point(field_get:Ssrc_Group.semantics)
  return semantics_.GetNoArena();
}
inline void Ssrc_Group::set_semantics(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  semantics_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Ssrc_Group.semantics)
}
#if LANG_CXX11
inline void Ssrc_Group::set_semantics(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  semantics_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Ssrc_Group.semantics)
}
#endif
inline void Ssrc_Group::set_semantics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  semantics_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Ssrc_Group.semantics)
}
inline void Ssrc_Group::set_semantics(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  semantics_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Ssrc_Group.semantics)
}
inline ::std::string* Ssrc_Group::mutable_semantics() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:Ssrc_Group.semantics)
  return semantics_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ssrc_Group::release_semantics() {
  // @@protoc_insertion_point(field_release:Ssrc_Group.semantics)
  if (!has_semantics()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return semantics_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ssrc_Group::set_allocated_semantics(::std::string* semantics) {
  if (semantics != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  semantics_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), semantics);
  // @@protoc_insertion_point(field_set_allocated:Ssrc_Group.semantics)
}

// repeated uint32 ssrcs = 2;
inline int Ssrc_Group::ssrcs_size() const {
  return ssrcs_.size();
}
inline void Ssrc_Group::clear_ssrcs() {
  ssrcs_.Clear();
}
inline ::google::protobuf::uint32 Ssrc_Group::ssrcs(int index) const {
  // @@protoc_insertion_point(field_get:Ssrc_Group.ssrcs)
  return ssrcs_.Get(index);
}
inline void Ssrc_Group::set_ssrcs(int index, ::google::protobuf::uint32 value) {
  ssrcs_.Set(index, value);
  // @@protoc_insertion_point(field_set:Ssrc_Group.ssrcs)
}
inline void Ssrc_Group::add_ssrcs(::google::protobuf::uint32 value) {
  ssrcs_.Add(value);
  // @@protoc_insertion_point(field_add:Ssrc_Group.ssrcs)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Ssrc_Group::ssrcs() const {
  // @@protoc_insertion_point(field_list:Ssrc_Group.ssrcs)
  return ssrcs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Ssrc_Group::mutable_ssrcs() {
  // @@protoc_insertion_point(field_mutable_list:Ssrc_Group.ssrcs)
  return &ssrcs_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Rid_Description

// optional string rid = 1;
inline bool Rid_Description::has_rid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rid_Description::clear_rid() {
  rid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Rid_Description::rid() const {
  // @@protoc_insertion_point(field_get:Rid_Description.rid)
  return rid_.GetNoArena();
}
inline void Rid_Description::set_rid(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  rid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rid_Description.rid)
}
#if LANG_CXX11
inline void Rid_Description::set_rid(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  rid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rid_Description.rid)
}
#endif
inline void Rid_Description::set_rid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  rid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rid_Description.rid)
}
inline void Rid_Description::set_rid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  rid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rid_Description.rid)
}
inline ::std::string* Rid_Description::mutable_rid() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:Rid_Description.rid)
  return rid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rid_Description::release_rid() {
  // @@protoc_insertion_point(field_release:Rid_Description.rid)
  if (!has_rid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return rid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rid_Description::set_allocated_rid(::std::string* rid) {
  if (rid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rid);
  // @@protoc_insertion_point(field_set_allocated:Rid_Description.rid)
}

// optional .Rid_Direction direction = 2;
inline bool Rid_Description::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rid_Description::clear_direction() {
  direction_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::Rid_Direction Rid_Description::direction() const {
  // @@protoc_insertion_point(field_get:Rid_Description.direction)
  return static_cast< ::Rid_Direction >(direction_);
}
inline void Rid_Description::set_direction(::Rid_Direction value) {
  assert(::Rid_Direction_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  direction_ = value;
  // @@protoc_insertion_point(field_set:Rid_Description.direction)
}

// repeated int32 payload_types = 3;
inline int Rid_Description::payload_types_size() const {
  return payload_types_.size();
}
inline void Rid_Description::clear_payload_types() {
  payload_types_.Clear();
}
inline ::google::protobuf::int32 Rid_Description::payload_types(int index) const {
  // @@protoc_insertion_point(field_get:Rid_Description.payload_types)
  return payload_types_.Get(index);
}
inline void Rid_Description::set_payload_types(int index, ::google::protobuf::int32 value) {
  payload_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:Rid_Description.payload_types)
}
inline void Rid_Description::add_payload_types(::google::protobuf::int32 value) {
  payload_types_.Add(value);
  // @@protoc_insertion_point(field_add:Rid_Description.payload_types)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Rid_Description::payload_types() const {
  // @@protoc_insertion_point(field_list:Rid_Description.payload_types)
  return payload_types_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Rid_Description::mutable_payload_types() {
  // @@protoc_insertion_point(field_mutable_list:Rid_Description.payload_types)
  return &payload_types_;
}

// map<string, string> restrictions = 4;
inline int Rid_Description::restrictions_size() const {
  return restrictions_.size();
}
inline void Rid_Description::clear_restrictions() {
  restrictions_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Rid_Description::restrictions() const {
  // @@protoc_insertion_point(field_map:Rid_Description.restrictions)
  return restrictions_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Rid_Description::mutable_restrictions() {
  // @@protoc_insertion_point(field_mutable_map:Rid_Description.restrictions)
  return restrictions_.MutableMap();
}

// -------------------------------------------------------------------

// Socket_Address

// optional string hostname = 1;
inline bool Socket_Address::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Socket_Address::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Socket_Address::hostname() const {
  // @@protoc_insertion_point(field_get:Socket_Address.hostname)
  return hostname_.GetNoArena();
}
inline void Socket_Address::set_hostname(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Socket_Address.hostname)
}
#if LANG_CXX11
inline void Socket_Address::set_hostname(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Socket_Address.hostname)
}
#endif
inline void Socket_Address::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Socket_Address.hostname)
}
inline void Socket_Address::set_hostname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Socket_Address.hostname)
}
inline ::std::string* Socket_Address::mutable_hostname() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:Socket_Address.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Socket_Address::release_hostname() {
  // @@protoc_insertion_point(field_release:Socket_Address.hostname)
  if (!has_hostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hostname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Socket_Address::set_allocated_hostname(::std::string* hostname) {
  if (hostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:Socket_Address.hostname)
}

// optional string ip = 2;
inline bool Socket_Address::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Socket_Address::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Socket_Address::ip() const {
  // @@protoc_insertion_point(field_get:Socket_Address.ip)
  return ip_.GetNoArena();
}
inline void Socket_Address::set_ip(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Socket_Address.ip)
}
#if LANG_CXX11
inline void Socket_Address::set_ip(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Socket_Address.ip)
}
#endif
inline void Socket_Address::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Socket_Address.ip)
}
inline void Socket_Address::set_ip(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Socket_Address.ip)
}
inline ::std::string* Socket_Address::mutable_ip() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:Socket_Address.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Socket_Address::release_ip() {
  // @@protoc_insertion_point(field_release:Socket_Address.ip)
  if (!has_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Socket_Address::set_allocated_ip(::std::string* ip) {
  if (ip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:Socket_Address.ip)
}

// optional uint32 port = 3;
inline bool Socket_Address::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Socket_Address::clear_port() {
  port_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 Socket_Address::port() const {
  // @@protoc_insertion_point(field_get:Socket_Address.port)
  return port_;
}
inline void Socket_Address::set_port(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  port_ = value;
  // @@protoc_insertion_point(field_set:Socket_Address.port)
}

// optional int32 scope_id = 4;
inline bool Socket_Address::has_scope_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Socket_Address::clear_scope_id() {
  scope_id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int32 Socket_Address::scope_id() const {
  // @@protoc_insertion_point(field_get:Socket_Address.scope_id)
  return scope_id_;
}
inline void Socket_Address::set_scope_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  scope_id_ = value;
  // @@protoc_insertion_point(field_set:Socket_Address.scope_id)
}

// optional bool literal = 5;
inline bool Socket_Address::has_literal() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Socket_Address::clear_literal() {
  literal_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Socket_Address::literal() const {
  // @@protoc_insertion_point(field_get:Socket_Address.literal)
  return literal_;
}
inline void Socket_Address::set_literal(bool value) {
  _has_bits_[0] |= 0x00000010u;
  literal_ = value;
  // @@protoc_insertion_point(field_set:Socket_Address.literal)
}

// -------------------------------------------------------------------

// Simulcast_Layer

// optional string rid = 1;
inline bool Simulcast_Layer::has_rid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Simulcast_Layer::clear_rid() {
  rid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Simulcast_Layer::rid() const {
  // @@protoc_insertion_point(field_get:Simulcast_Layer.rid)
  return rid_.GetNoArena();
}
inline void Simulcast_Layer::set_rid(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  rid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Simulcast_Layer.rid)
}
#if LANG_CXX11
inline void Simulcast_Layer::set_rid(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  rid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Simulcast_Layer.rid)
}
#endif
inline void Simulcast_Layer::set_rid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  rid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Simulcast_Layer.rid)
}
inline void Simulcast_Layer::set_rid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  rid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Simulcast_Layer.rid)
}
inline ::std::string* Simulcast_Layer::mutable_rid() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:Simulcast_Layer.rid)
  return rid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Simulcast_Layer::release_rid() {
  // @@protoc_insertion_point(field_release:Simulcast_Layer.rid)
  if (!has_rid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return rid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Simulcast_Layer::set_allocated_rid(::std::string* rid) {
  if (rid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rid);
  // @@protoc_insertion_point(field_set_allocated:Simulcast_Layer.rid)
}

// optional bool is_paused = 2;
inline bool Simulcast_Layer::has_is_paused() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Simulcast_Layer::clear_is_paused() {
  is_paused_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Simulcast_Layer::is_paused() const {
  // @@protoc_insertion_point(field_get:Simulcast_Layer.is_paused)
  return is_paused_;
}
inline void Simulcast_Layer::set_is_paused(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_paused_ = value;
  // @@protoc_insertion_point(field_set:Simulcast_Layer.is_paused)
}

// -------------------------------------------------------------------

// Simulcast_Layer_List

// repeated .Simulcast_Layer list = 1;
inline int Simulcast_Layer_List::list_size() const {
  return list_.size();
}
inline void Simulcast_Layer_List::clear_list() {
  list_.Clear();
}
inline ::Simulcast_Layer* Simulcast_Layer_List::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:Simulcast_Layer_List.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer >*
Simulcast_Layer_List::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:Simulcast_Layer_List.list)
  return &list_;
}
inline const ::Simulcast_Layer& Simulcast_Layer_List::list(int index) const {
  // @@protoc_insertion_point(field_get:Simulcast_Layer_List.list)
  return list_.Get(index);
}
inline ::Simulcast_Layer* Simulcast_Layer_List::add_list() {
  // @@protoc_insertion_point(field_add:Simulcast_Layer_List.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer >&
Simulcast_Layer_List::list() const {
  // @@protoc_insertion_point(field_list:Simulcast_Layer_List.list)
  return list_;
}

// -------------------------------------------------------------------

// Simulcast_Description

// repeated .Simulcast_Layer_List send_layers = 1;
inline int Simulcast_Description::send_layers_size() const {
  return send_layers_.size();
}
inline void Simulcast_Description::clear_send_layers() {
  send_layers_.Clear();
}
inline ::Simulcast_Layer_List* Simulcast_Description::mutable_send_layers(int index) {
  // @@protoc_insertion_point(field_mutable:Simulcast_Description.send_layers)
  return send_layers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer_List >*
Simulcast_Description::mutable_send_layers() {
  // @@protoc_insertion_point(field_mutable_list:Simulcast_Description.send_layers)
  return &send_layers_;
}
inline const ::Simulcast_Layer_List& Simulcast_Description::send_layers(int index) const {
  // @@protoc_insertion_point(field_get:Simulcast_Description.send_layers)
  return send_layers_.Get(index);
}
inline ::Simulcast_Layer_List* Simulcast_Description::add_send_layers() {
  // @@protoc_insertion_point(field_add:Simulcast_Description.send_layers)
  return send_layers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer_List >&
Simulcast_Description::send_layers() const {
  // @@protoc_insertion_point(field_list:Simulcast_Description.send_layers)
  return send_layers_;
}

// repeated .Simulcast_Layer_List receive_layers = 2;
inline int Simulcast_Description::receive_layers_size() const {
  return receive_layers_.size();
}
inline void Simulcast_Description::clear_receive_layers() {
  receive_layers_.Clear();
}
inline ::Simulcast_Layer_List* Simulcast_Description::mutable_receive_layers(int index) {
  // @@protoc_insertion_point(field_mutable:Simulcast_Description.receive_layers)
  return receive_layers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer_List >*
Simulcast_Description::mutable_receive_layers() {
  // @@protoc_insertion_point(field_mutable_list:Simulcast_Description.receive_layers)
  return &receive_layers_;
}
inline const ::Simulcast_Layer_List& Simulcast_Description::receive_layers(int index) const {
  // @@protoc_insertion_point(field_get:Simulcast_Description.receive_layers)
  return receive_layers_.Get(index);
}
inline ::Simulcast_Layer_List* Simulcast_Description::add_receive_layers() {
  // @@protoc_insertion_point(field_add:Simulcast_Description.receive_layers)
  return receive_layers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Simulcast_Layer_List >&
Simulcast_Description::receive_layers() const {
  // @@protoc_insertion_point(field_list:Simulcast_Description.receive_layers)
  return receive_layers_;
}

// -------------------------------------------------------------------

// RTC_Candidate

// -------------------------------------------------------------------

// Rtc_Ssrc_Info

// optional uint32 ssrc_id = 1;
inline bool Rtc_Ssrc_Info::has_ssrc_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Rtc_Ssrc_Info::clear_ssrc_id() {
  ssrc_id_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 Rtc_Ssrc_Info::ssrc_id() const {
  // @@protoc_insertion_point(field_get:Rtc_Ssrc_Info.ssrc_id)
  return ssrc_id_;
}
inline void Rtc_Ssrc_Info::set_ssrc_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  ssrc_id_ = value;
  // @@protoc_insertion_point(field_set:Rtc_Ssrc_Info.ssrc_id)
}

// optional string cname = 2;
inline bool Rtc_Ssrc_Info::has_cname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rtc_Ssrc_Info::clear_cname() {
  cname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Rtc_Ssrc_Info::cname() const {
  // @@protoc_insertion_point(field_get:Rtc_Ssrc_Info.cname)
  return cname_.GetNoArena();
}
inline void Rtc_Ssrc_Info::set_cname(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Ssrc_Info.cname)
}
#if LANG_CXX11
inline void Rtc_Ssrc_Info::set_cname(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  cname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Ssrc_Info.cname)
}
#endif
inline void Rtc_Ssrc_Info::set_cname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  cname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Ssrc_Info.cname)
}
inline void Rtc_Ssrc_Info::set_cname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  cname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Ssrc_Info.cname)
}
inline ::std::string* Rtc_Ssrc_Info::mutable_cname() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:Rtc_Ssrc_Info.cname)
  return cname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Ssrc_Info::release_cname() {
  // @@protoc_insertion_point(field_release:Rtc_Ssrc_Info.cname)
  if (!has_cname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return cname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Ssrc_Info::set_allocated_cname(::std::string* cname) {
  if (cname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cname);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Ssrc_Info.cname)
}

// optional string stream_id = 3;
inline bool Rtc_Ssrc_Info::has_stream_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rtc_Ssrc_Info::clear_stream_id() {
  stream_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Rtc_Ssrc_Info::stream_id() const {
  // @@protoc_insertion_point(field_get:Rtc_Ssrc_Info.stream_id)
  return stream_id_.GetNoArena();
}
inline void Rtc_Ssrc_Info::set_stream_id(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  stream_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Ssrc_Info.stream_id)
}
#if LANG_CXX11
inline void Rtc_Ssrc_Info::set_stream_id(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  stream_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Ssrc_Info.stream_id)
}
#endif
inline void Rtc_Ssrc_Info::set_stream_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  stream_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Ssrc_Info.stream_id)
}
inline void Rtc_Ssrc_Info::set_stream_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  stream_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Ssrc_Info.stream_id)
}
inline ::std::string* Rtc_Ssrc_Info::mutable_stream_id() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:Rtc_Ssrc_Info.stream_id)
  return stream_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Ssrc_Info::release_stream_id() {
  // @@protoc_insertion_point(field_release:Rtc_Ssrc_Info.stream_id)
  if (!has_stream_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return stream_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Ssrc_Info::set_allocated_stream_id(::std::string* stream_id) {
  if (stream_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  stream_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stream_id);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Ssrc_Info.stream_id)
}

// optional string track_id = 4;
inline bool Rtc_Ssrc_Info::has_track_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rtc_Ssrc_Info::clear_track_id() {
  track_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& Rtc_Ssrc_Info::track_id() const {
  // @@protoc_insertion_point(field_get:Rtc_Ssrc_Info.track_id)
  return track_id_.GetNoArena();
}
inline void Rtc_Ssrc_Info::set_track_id(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  track_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Ssrc_Info.track_id)
}
#if LANG_CXX11
inline void Rtc_Ssrc_Info::set_track_id(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  track_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Ssrc_Info.track_id)
}
#endif
inline void Rtc_Ssrc_Info::set_track_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  track_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Ssrc_Info.track_id)
}
inline void Rtc_Ssrc_Info::set_track_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  track_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Ssrc_Info.track_id)
}
inline ::std::string* Rtc_Ssrc_Info::mutable_track_id() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:Rtc_Ssrc_Info.track_id)
  return track_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Ssrc_Info::release_track_id() {
  // @@protoc_insertion_point(field_release:Rtc_Ssrc_Info.track_id)
  if (!has_track_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return track_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Ssrc_Info::set_allocated_track_id(::std::string* track_id) {
  if (track_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  track_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), track_id);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Ssrc_Info.track_id)
}

// optional string label = 5;
inline bool Rtc_Ssrc_Info::has_label() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rtc_Ssrc_Info::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& Rtc_Ssrc_Info::label() const {
  // @@protoc_insertion_point(field_get:Rtc_Ssrc_Info.label)
  return label_.GetNoArena();
}
inline void Rtc_Ssrc_Info::set_label(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Ssrc_Info.label)
}
#if LANG_CXX11
inline void Rtc_Ssrc_Info::set_label(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Ssrc_Info.label)
}
#endif
inline void Rtc_Ssrc_Info::set_label(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Ssrc_Info.label)
}
inline void Rtc_Ssrc_Info::set_label(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Ssrc_Info.label)
}
inline ::std::string* Rtc_Ssrc_Info::mutable_label() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:Rtc_Ssrc_Info.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Ssrc_Info::release_label() {
  // @@protoc_insertion_point(field_release:Rtc_Ssrc_Info.label)
  if (!has_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return label_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Ssrc_Info::set_allocated_label(::std::string* label) {
  if (label != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Ssrc_Info.label)
}

// optional string mslabel = 6;
inline bool Rtc_Ssrc_Info::has_mslabel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Rtc_Ssrc_Info::clear_mslabel() {
  mslabel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& Rtc_Ssrc_Info::mslabel() const {
  // @@protoc_insertion_point(field_get:Rtc_Ssrc_Info.mslabel)
  return mslabel_.GetNoArena();
}
inline void Rtc_Ssrc_Info::set_mslabel(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  mslabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Ssrc_Info.mslabel)
}
#if LANG_CXX11
inline void Rtc_Ssrc_Info::set_mslabel(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  mslabel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Ssrc_Info.mslabel)
}
#endif
inline void Rtc_Ssrc_Info::set_mslabel(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  mslabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Ssrc_Info.mslabel)
}
inline void Rtc_Ssrc_Info::set_mslabel(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  mslabel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Ssrc_Info.mslabel)
}
inline ::std::string* Rtc_Ssrc_Info::mutable_mslabel() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:Rtc_Ssrc_Info.mslabel)
  return mslabel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Ssrc_Info::release_mslabel() {
  // @@protoc_insertion_point(field_release:Rtc_Ssrc_Info.mslabel)
  if (!has_mslabel()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return mslabel_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Ssrc_Info::set_allocated_mslabel(::std::string* mslabel) {
  if (mslabel != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  mslabel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mslabel);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Ssrc_Info.mslabel)
}

// -------------------------------------------------------------------

// Rtc_Feedback_Param

// optional string id = 1;
inline bool Rtc_Feedback_Param::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rtc_Feedback_Param::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Rtc_Feedback_Param::id() const {
  // @@protoc_insertion_point(field_get:Rtc_Feedback_Param.id)
  return id_.GetNoArena();
}
inline void Rtc_Feedback_Param::set_id(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Feedback_Param.id)
}
#if LANG_CXX11
inline void Rtc_Feedback_Param::set_id(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Feedback_Param.id)
}
#endif
inline void Rtc_Feedback_Param::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Feedback_Param.id)
}
inline void Rtc_Feedback_Param::set_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Feedback_Param.id)
}
inline ::std::string* Rtc_Feedback_Param::mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:Rtc_Feedback_Param.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Feedback_Param::release_id() {
  // @@protoc_insertion_point(field_release:Rtc_Feedback_Param.id)
  if (!has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Feedback_Param::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Feedback_Param.id)
}

// optional string param = 2;
inline bool Rtc_Feedback_Param::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rtc_Feedback_Param::clear_param() {
  param_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Rtc_Feedback_Param::param() const {
  // @@protoc_insertion_point(field_get:Rtc_Feedback_Param.param)
  return param_.GetNoArena();
}
inline void Rtc_Feedback_Param::set_param(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  param_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Feedback_Param.param)
}
#if LANG_CXX11
inline void Rtc_Feedback_Param::set_param(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  param_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Feedback_Param.param)
}
#endif
inline void Rtc_Feedback_Param::set_param(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  param_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Feedback_Param.param)
}
inline void Rtc_Feedback_Param::set_param(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  param_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Feedback_Param.param)
}
inline ::std::string* Rtc_Feedback_Param::mutable_param() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:Rtc_Feedback_Param.param)
  return param_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Feedback_Param::release_param() {
  // @@protoc_insertion_point(field_release:Rtc_Feedback_Param.param)
  if (!has_param()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return param_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Feedback_Param::set_allocated_param(::std::string* param) {
  if (param != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  param_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), param);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Feedback_Param.param)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Rtc_Codec

// optional int32 id = 1;
inline bool Rtc_Codec::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rtc_Codec::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 Rtc_Codec::id() const {
  // @@protoc_insertion_point(field_get:Rtc_Codec.id)
  return id_;
}
inline void Rtc_Codec::set_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
  // @@protoc_insertion_point(field_set:Rtc_Codec.id)
}

// optional string name = 2;
inline bool Rtc_Codec::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rtc_Codec::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Rtc_Codec::name() const {
  // @@protoc_insertion_point(field_get:Rtc_Codec.name)
  return name_.GetNoArena();
}
inline void Rtc_Codec::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Codec.name)
}
#if LANG_CXX11
inline void Rtc_Codec::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Codec.name)
}
#endif
inline void Rtc_Codec::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Codec.name)
}
inline void Rtc_Codec::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Codec.name)
}
inline ::std::string* Rtc_Codec::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:Rtc_Codec.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Codec::release_name() {
  // @@protoc_insertion_point(field_release:Rtc_Codec.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Codec::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Codec.name)
}

// optional int32 clockrate = 3;
inline bool Rtc_Codec::has_clockrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rtc_Codec::clear_clockrate() {
  clockrate_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 Rtc_Codec::clockrate() const {
  // @@protoc_insertion_point(field_get:Rtc_Codec.clockrate)
  return clockrate_;
}
inline void Rtc_Codec::set_clockrate(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  clockrate_ = value;
  // @@protoc_insertion_point(field_set:Rtc_Codec.clockrate)
}

// map<string, string> params = 4;
inline int Rtc_Codec::params_size() const {
  return params_.size();
}
inline void Rtc_Codec::clear_params() {
  params_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Rtc_Codec::params() const {
  // @@protoc_insertion_point(field_map:Rtc_Codec.params)
  return params_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Rtc_Codec::mutable_params() {
  // @@protoc_insertion_point(field_mutable_map:Rtc_Codec.params)
  return params_.MutableMap();
}

// repeated .Rtc_Feedback_Param feedback_params = 5;
inline int Rtc_Codec::feedback_params_size() const {
  return feedback_params_.size();
}
inline void Rtc_Codec::clear_feedback_params() {
  feedback_params_.Clear();
}
inline ::Rtc_Feedback_Param* Rtc_Codec::mutable_feedback_params(int index) {
  // @@protoc_insertion_point(field_mutable:Rtc_Codec.feedback_params)
  return feedback_params_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Rtc_Feedback_Param >*
Rtc_Codec::mutable_feedback_params() {
  // @@protoc_insertion_point(field_mutable_list:Rtc_Codec.feedback_params)
  return &feedback_params_;
}
inline const ::Rtc_Feedback_Param& Rtc_Codec::feedback_params(int index) const {
  // @@protoc_insertion_point(field_get:Rtc_Codec.feedback_params)
  return feedback_params_.Get(index);
}
inline ::Rtc_Feedback_Param* Rtc_Codec::add_feedback_params() {
  // @@protoc_insertion_point(field_add:Rtc_Codec.feedback_params)
  return feedback_params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Rtc_Feedback_Param >&
Rtc_Codec::feedback_params() const {
  // @@protoc_insertion_point(field_list:Rtc_Codec.feedback_params)
  return feedback_params_;
}

// -------------------------------------------------------------------

// Rtc_Audio_Codec

// optional int32 bitrate = 1;
inline bool Rtc_Audio_Codec::has_bitrate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rtc_Audio_Codec::clear_bitrate() {
  bitrate_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 Rtc_Audio_Codec::bitrate() const {
  // @@protoc_insertion_point(field_get:Rtc_Audio_Codec.bitrate)
  return bitrate_;
}
inline void Rtc_Audio_Codec::set_bitrate(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  bitrate_ = value;
  // @@protoc_insertion_point(field_set:Rtc_Audio_Codec.bitrate)
}

// optional int32 channels = 2;
inline bool Rtc_Audio_Codec::has_channels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rtc_Audio_Codec::clear_channels() {
  channels_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 Rtc_Audio_Codec::channels() const {
  // @@protoc_insertion_point(field_get:Rtc_Audio_Codec.channels)
  return channels_;
}
inline void Rtc_Audio_Codec::set_channels(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  channels_ = value;
  // @@protoc_insertion_point(field_set:Rtc_Audio_Codec.channels)
}

// optional .Rtc_Codec codecs = 3;
inline bool Rtc_Audio_Codec::has_codecs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rtc_Audio_Codec::clear_codecs() {
  if (codecs_ != nullptr) codecs_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Rtc_Codec& Rtc_Audio_Codec::codecs() const {
  const ::Rtc_Codec* p = codecs_;
  // @@protoc_insertion_point(field_get:Rtc_Audio_Codec.codecs)
  return p != nullptr ? *p : *reinterpret_cast<const ::Rtc_Codec*>(
      &::_Rtc_Codec_default_instance_);
}
inline ::Rtc_Codec* Rtc_Audio_Codec::release_codecs() {
  // @@protoc_insertion_point(field_release:Rtc_Audio_Codec.codecs)
  _has_bits_[0] &= ~0x00000001u;
  ::Rtc_Codec* temp = codecs_;
  codecs_ = nullptr;
  return temp;
}
inline ::Rtc_Codec* Rtc_Audio_Codec::mutable_codecs() {
  _has_bits_[0] |= 0x00000001u;
  if (codecs_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rtc_Codec>(GetArenaNoVirtual());
    codecs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Rtc_Audio_Codec.codecs)
  return codecs_;
}
inline void Rtc_Audio_Codec::set_allocated_codecs(::Rtc_Codec* codecs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete codecs_;
  }
  if (codecs) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      codecs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, codecs, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  codecs_ = codecs;
  // @@protoc_insertion_point(field_set_allocated:Rtc_Audio_Codec.codecs)
}

// -------------------------------------------------------------------

// Rtc_Video_Codec

// optional .Rtc_Codec codecs = 1;
inline bool Rtc_Video_Codec::has_codecs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rtc_Video_Codec::clear_codecs() {
  if (codecs_ != nullptr) codecs_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Rtc_Codec& Rtc_Video_Codec::codecs() const {
  const ::Rtc_Codec* p = codecs_;
  // @@protoc_insertion_point(field_get:Rtc_Video_Codec.codecs)
  return p != nullptr ? *p : *reinterpret_cast<const ::Rtc_Codec*>(
      &::_Rtc_Codec_default_instance_);
}
inline ::Rtc_Codec* Rtc_Video_Codec::release_codecs() {
  // @@protoc_insertion_point(field_release:Rtc_Video_Codec.codecs)
  _has_bits_[0] &= ~0x00000001u;
  ::Rtc_Codec* temp = codecs_;
  codecs_ = nullptr;
  return temp;
}
inline ::Rtc_Codec* Rtc_Video_Codec::mutable_codecs() {
  _has_bits_[0] |= 0x00000001u;
  if (codecs_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rtc_Codec>(GetArenaNoVirtual());
    codecs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Rtc_Video_Codec.codecs)
  return codecs_;
}
inline void Rtc_Video_Codec::set_allocated_codecs(::Rtc_Codec* codecs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete codecs_;
  }
  if (codecs) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      codecs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, codecs, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  codecs_ = codecs;
  // @@protoc_insertion_point(field_set_allocated:Rtc_Video_Codec.codecs)
}

// -------------------------------------------------------------------

// Rtc_Data_Codec

// optional .Rtc_Codec codecs = 1;
inline bool Rtc_Data_Codec::has_codecs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rtc_Data_Codec::clear_codecs() {
  if (codecs_ != nullptr) codecs_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Rtc_Codec& Rtc_Data_Codec::codecs() const {
  const ::Rtc_Codec* p = codecs_;
  // @@protoc_insertion_point(field_get:Rtc_Data_Codec.codecs)
  return p != nullptr ? *p : *reinterpret_cast<const ::Rtc_Codec*>(
      &::_Rtc_Codec_default_instance_);
}
inline ::Rtc_Codec* Rtc_Data_Codec::release_codecs() {
  // @@protoc_insertion_point(field_release:Rtc_Data_Codec.codecs)
  _has_bits_[0] &= ~0x00000001u;
  ::Rtc_Codec* temp = codecs_;
  codecs_ = nullptr;
  return temp;
}
inline ::Rtc_Codec* Rtc_Data_Codec::mutable_codecs() {
  _has_bits_[0] |= 0x00000001u;
  if (codecs_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rtc_Codec>(GetArenaNoVirtual());
    codecs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Rtc_Data_Codec.codecs)
  return codecs_;
}
inline void Rtc_Data_Codec::set_allocated_codecs(::Rtc_Codec* codecs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete codecs_;
  }
  if (codecs) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      codecs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, codecs, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  codecs_ = codecs;
  // @@protoc_insertion_point(field_set_allocated:Rtc_Data_Codec.codecs)
}

// -------------------------------------------------------------------

// Rtc_Candidate

// optional string id = 1;
inline bool Rtc_Candidate::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rtc_Candidate::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Rtc_Candidate::id() const {
  // @@protoc_insertion_point(field_get:Rtc_Candidate.id)
  return id_.GetNoArena();
}
inline void Rtc_Candidate::set_id(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Candidate.id)
}
#if LANG_CXX11
inline void Rtc_Candidate::set_id(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Candidate.id)
}
#endif
inline void Rtc_Candidate::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Candidate.id)
}
inline void Rtc_Candidate::set_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Candidate.id)
}
inline ::std::string* Rtc_Candidate::mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:Rtc_Candidate.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Candidate::release_id() {
  // @@protoc_insertion_point(field_release:Rtc_Candidate.id)
  if (!has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Candidate::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Candidate.id)
}

// optional int32 component = 2;
inline bool Rtc_Candidate::has_component() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Rtc_Candidate::clear_component() {
  component_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::int32 Rtc_Candidate::component() const {
  // @@protoc_insertion_point(field_get:Rtc_Candidate.component)
  return component_;
}
inline void Rtc_Candidate::set_component(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  component_ = value;
  // @@protoc_insertion_point(field_set:Rtc_Candidate.component)
}

// optional string protocol = 3;
inline bool Rtc_Candidate::has_protocol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rtc_Candidate::clear_protocol() {
  protocol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Rtc_Candidate::protocol() const {
  // @@protoc_insertion_point(field_get:Rtc_Candidate.protocol)
  return protocol_.GetNoArena();
}
inline void Rtc_Candidate::set_protocol(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Candidate.protocol)
}
#if LANG_CXX11
inline void Rtc_Candidate::set_protocol(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  protocol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Candidate.protocol)
}
#endif
inline void Rtc_Candidate::set_protocol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Candidate.protocol)
}
inline void Rtc_Candidate::set_protocol(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Candidate.protocol)
}
inline ::std::string* Rtc_Candidate::mutable_protocol() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:Rtc_Candidate.protocol)
  return protocol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Candidate::release_protocol() {
  // @@protoc_insertion_point(field_release:Rtc_Candidate.protocol)
  if (!has_protocol()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return protocol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Candidate::set_allocated_protocol(::std::string* protocol) {
  if (protocol != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  protocol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Candidate.protocol)
}

// optional string relay_protocol = 4;
inline bool Rtc_Candidate::has_relay_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rtc_Candidate::clear_relay_protocol() {
  relay_protocol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& Rtc_Candidate::relay_protocol() const {
  // @@protoc_insertion_point(field_get:Rtc_Candidate.relay_protocol)
  return relay_protocol_.GetNoArena();
}
inline void Rtc_Candidate::set_relay_protocol(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  relay_protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Candidate.relay_protocol)
}
#if LANG_CXX11
inline void Rtc_Candidate::set_relay_protocol(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  relay_protocol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Candidate.relay_protocol)
}
#endif
inline void Rtc_Candidate::set_relay_protocol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  relay_protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Candidate.relay_protocol)
}
inline void Rtc_Candidate::set_relay_protocol(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  relay_protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Candidate.relay_protocol)
}
inline ::std::string* Rtc_Candidate::mutable_relay_protocol() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:Rtc_Candidate.relay_protocol)
  return relay_protocol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Candidate::release_relay_protocol() {
  // @@protoc_insertion_point(field_release:Rtc_Candidate.relay_protocol)
  if (!has_relay_protocol()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return relay_protocol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Candidate::set_allocated_relay_protocol(::std::string* relay_protocol) {
  if (relay_protocol != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  relay_protocol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), relay_protocol);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Candidate.relay_protocol)
}

// optional .Socket_Address address = 5;
inline bool Rtc_Candidate::has_address() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Rtc_Candidate::clear_address() {
  if (address_ != nullptr) address_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::Socket_Address& Rtc_Candidate::address() const {
  const ::Socket_Address* p = address_;
  // @@protoc_insertion_point(field_get:Rtc_Candidate.address)
  return p != nullptr ? *p : *reinterpret_cast<const ::Socket_Address*>(
      &::_Socket_Address_default_instance_);
}
inline ::Socket_Address* Rtc_Candidate::release_address() {
  // @@protoc_insertion_point(field_release:Rtc_Candidate.address)
  _has_bits_[0] &= ~0x00000040u;
  ::Socket_Address* temp = address_;
  address_ = nullptr;
  return temp;
}
inline ::Socket_Address* Rtc_Candidate::mutable_address() {
  _has_bits_[0] |= 0x00000040u;
  if (address_ == nullptr) {
    auto* p = CreateMaybeMessage<::Socket_Address>(GetArenaNoVirtual());
    address_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Rtc_Candidate.address)
  return address_;
}
inline void Rtc_Candidate::set_allocated_address(::Socket_Address* address) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete address_;
  }
  if (address) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      address = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:Rtc_Candidate.address)
}

// optional uint32 priority = 6;
inline bool Rtc_Candidate::has_priority() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Rtc_Candidate::clear_priority() {
  priority_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 Rtc_Candidate::priority() const {
  // @@protoc_insertion_point(field_get:Rtc_Candidate.priority)
  return priority_;
}
inline void Rtc_Candidate::set_priority(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  priority_ = value;
  // @@protoc_insertion_point(field_set:Rtc_Candidate.priority)
}

// optional string username = 7;
inline bool Rtc_Candidate::has_username() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rtc_Candidate::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& Rtc_Candidate::username() const {
  // @@protoc_insertion_point(field_get:Rtc_Candidate.username)
  return username_.GetNoArena();
}
inline void Rtc_Candidate::set_username(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Candidate.username)
}
#if LANG_CXX11
inline void Rtc_Candidate::set_username(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Candidate.username)
}
#endif
inline void Rtc_Candidate::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Candidate.username)
}
inline void Rtc_Candidate::set_username(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Candidate.username)
}
inline ::std::string* Rtc_Candidate::mutable_username() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:Rtc_Candidate.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Candidate::release_username() {
  // @@protoc_insertion_point(field_release:Rtc_Candidate.username)
  if (!has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Candidate::set_allocated_username(::std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Candidate.username)
}

// optional string password = 8;
inline bool Rtc_Candidate::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Rtc_Candidate::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& Rtc_Candidate::password() const {
  // @@protoc_insertion_point(field_get:Rtc_Candidate.password)
  return password_.GetNoArena();
}
inline void Rtc_Candidate::set_password(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Candidate.password)
}
#if LANG_CXX11
inline void Rtc_Candidate::set_password(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Candidate.password)
}
#endif
inline void Rtc_Candidate::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Candidate.password)
}
inline void Rtc_Candidate::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Candidate.password)
}
inline ::std::string* Rtc_Candidate::mutable_password() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:Rtc_Candidate.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Candidate::release_password() {
  // @@protoc_insertion_point(field_release:Rtc_Candidate.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return password_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Candidate::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Candidate.password)
}

// optional string type = 9;
inline bool Rtc_Candidate::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Rtc_Candidate::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& Rtc_Candidate::type() const {
  // @@protoc_insertion_point(field_get:Rtc_Candidate.type)
  return type_.GetNoArena();
}
inline void Rtc_Candidate::set_type(const ::std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rtc_Candidate.type)
}
#if LANG_CXX11
inline void Rtc_Candidate::set_type(::std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rtc_Candidate.type)
}
#endif
inline void Rtc_Candidate::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rtc_Candidate.type)
}
inline void Rtc_Candidate::set_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rtc_Candidate.type)
}
inline ::std::string* Rtc_Candidate::mutable_type() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:Rtc_Candidate.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rtc_Candidate::release_type() {
  // @@protoc_insertion_point(field_release:Rtc_Candidate.type)
  if (!has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rtc_Candidate::set_allocated_type(::std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:Rtc_Candidate.type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_RtcSdpDefine_2eproto
